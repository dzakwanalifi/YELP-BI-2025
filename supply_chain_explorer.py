"""
Supply Chain Spatial Analysis - Riset Pengaruh Supply Chain terhadap Harga
============================================================================

Tujuan Riset:
- Mapping SEMUA supply chain entities di SEMUA lokasi (tidak peduli zona produksi/distribusi)
- Analisis korelasi spasial: jarak ke produsen/distributor vs harga komoditas
- Identifikasi gap infrastruktur yang bisa dioptimalisasi
- Insight untuk optimalisasi distribusi dan stabilisasi harga

Strategi:
- Cari SEMUA jenis fasilitas (production, storage, distribution, retail) di SETIAP lokasi
- Hitung jarak dari setiap lokasi ke fasilitas terdekat
- Nantinya bisa analisis: apakah kedekatan dengan produsen = harga lebih murah?
- Apakah ada produsen di kota konsumsi yang bisa menurunkan harga?

Data Output:
- supply_chain_facilities.csv: Semua fasilitas yang ditemukan
- location_facility_summary.csv: Jumlah fasilitas per lokasi per tipe
- spatial_features.csv: Features untuk analisis (jarak ke fasilitas terdekat, dll)

Author: Generated by Claude Code
Date: 2025-11-28
"""

import requests
import pandas as pd
import json
import os
from datetime import datetime
from typing import List, Dict, Optional
import logging
from multiprocessing import Pool, cpu_count
from tqdm import tqdm
import time
import math
import random

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Output directory
OUTPUT_DIR = 'supply_chain_spatial_fast'
os.makedirs(OUTPUT_DIR, exist_ok=True)

# ============================================================================
# OVERPASS SERVER ROTATION (Load Balancing)
# ============================================================================
# Daftar server publik Overpass untuk menghindari bottleneck di satu IP
OVERPASS_SERVERS = [
    "https://overpass-api.de/api/interpreter",
    "https://lz4.overpass-api.de/api/interpreter",
    "https://overpass.kumi.systems/api/interpreter",
    "https://maps.mail.ru/osm/tools/overpass/api/interpreter",
    "https://overpass.openstreetmap.ru/api/interpreter"
]


# ============================================================================
# LOCATION COORDINATES - Semua lokasi PIHPS
# ============================================================================
LOCATION_COORDS = {
    'Jakarta Pusat': (-6.1862, 106.8346),
    'Sukabumi': (-6.9278, 106.9271),
    'Tasikmalaya': (-7.3274, 108.2207),
    'Kab. Tasikmalaya': (-7.3506, 108.2050),
    'Kab. Cirebon': (-6.7405, 108.3402),
    'Cirebon': (-6.7063, 108.5571),
    'Depok': (-6.4025, 106.7942),
    'Bekasi': (-6.2383, 106.9756),
    'Bogor': (-6.5950, 106.7890),
    'Bandung': (-6.9175, 107.6191)
}

# Radius pencarian dalam meter dari titik pusat kota
SEARCH_RADIUS_METERS = 15000  # 15 KM radius


# ============================================================================
# COMPREHENSIVE SUPPLY CHAIN TAGS - Untuk Analisis Spasial
# ============================================================================
# Kita cari SEMUA jenis fasilitas untuk analisis pengaruh terhadap harga
# ============================================================================

SUPPLY_CHAIN_TAGS = {
    # ========================================================================
    # 1. BERAS / RICE
    # ========================================================================
    'Beras': {
        'pihps_commodities': [
            'Beras Kualitas Bawah I', 'Beras Kualitas Bawah II',
            'Beras Kualitas Medium I', 'Beras Kualitas Medium II',
            'Beras Kualitas Super I', 'Beras Kualitas Super II'
        ],
        'facilities': [
            # Production
            {'type': 'production', 'tags': {'craft': 'rice_mill'}, 'label': 'Rice Mill'},
            {'type': 'production', 'tags': {'industrial': 'mill', 'product': 'rice'}, 'label': 'Industrial Rice Mill'},
            {'type': 'production', 'tags': {'landuse': 'farmland', 'crop': 'rice'}, 'label': 'Rice Farm'},
            {'type': 'production', 'tags': {'building': 'farm', 'crop': 'rice'}, 'label': 'Rice Farm Building'},

            # Storage
            {'type': 'storage', 'tags': {'building': 'warehouse', 'product': 'rice'}, 'label': 'Rice Warehouse'},
            {'type': 'storage', 'tags': {'man_made': 'storage_tank', 'content': 'grain'}, 'label': 'Grain Storage'},

            # Distribution
            {'type': 'distribution', 'tags': {'shop': 'wholesale'}, 'label': 'Wholesale Market'},
            {'type': 'distribution', 'tags': {'amenity': 'marketplace'}, 'label': 'Traditional Market'},

            # Retail
            {'type': 'retail', 'tags': {'shop': 'convenience'}, 'label': 'Convenience Store'},
            {'type': 'retail', 'tags': {'shop': 'supermarket'}, 'label': 'Supermarket'},
        ]
    },

    # ========================================================================
    # 2. BAWANG MERAH / SHALLOTS
    # ========================================================================
    'Bawang Merah': {
        'pihps_commodities': ['Bawang Merah Ukuran Sedang'],
        'facilities': [
            {'type': 'production', 'tags': {'landuse': 'farmland', 'crop': 'onion'}, 'label': 'Onion Farm'},
            {'type': 'production', 'tags': {'building': 'farm', 'crop': 'vegetables'}, 'label': 'Vegetable Farm'},
            {'type': 'storage', 'tags': {'building': 'warehouse', 'product': 'vegetables'}, 'label': 'Vegetable Warehouse'},
            {'type': 'distribution', 'tags': {'shop': 'wholesale'}, 'label': 'Wholesale Market'},
            {'type': 'distribution', 'tags': {'amenity': 'marketplace'}, 'label': 'Traditional Market'},
            {'type': 'retail', 'tags': {'shop': 'greengrocer'}, 'label': 'Greengrocer'},
        ]
    },

    # ========================================================================
    # 3. BAWANG PUTIH / GARLIC
    # ========================================================================
    'Bawang Putih': {
        'pihps_commodities': ['Bawang Putih Ukuran Sedang'],
        'facilities': [
            {'type': 'production', 'tags': {'landuse': 'farmland', 'crop': 'garlic'}, 'label': 'Garlic Farm'},
            {'type': 'production', 'tags': {'building': 'farm', 'crop': 'vegetables'}, 'label': 'Vegetable Farm'},
            {'type': 'storage', 'tags': {'building': 'warehouse', 'product': 'vegetables'}, 'label': 'Vegetable Warehouse'},
            {'type': 'distribution', 'tags': {'shop': 'wholesale'}, 'label': 'Wholesale Market'},
            {'type': 'distribution', 'tags': {'amenity': 'marketplace'}, 'label': 'Traditional Market'},
            {'type': 'retail', 'tags': {'shop': 'greengrocer'}, 'label': 'Greengrocer'},
        ]
    },

    # ========================================================================
    # 4. CABAI / CHILI
    # ========================================================================
    'Cabai': {
        'pihps_commodities': [
            'Cabai Merah Besar', 'Cabai Merah Keriting',
            'Cabai Rawit Hijau', 'Cabai Rawit Merah'
        ],
        'facilities': [
            {'type': 'production', 'tags': {'landuse': 'farmland', 'crop': 'pepper'}, 'label': 'Chili Farm'},
            {'type': 'production', 'tags': {'building': 'farm', 'crop': 'vegetables'}, 'label': 'Vegetable Farm'},
            {'type': 'production', 'tags': {'landuse': 'greenhouse_horticulture'}, 'label': 'Greenhouse'},
            {'type': 'storage', 'tags': {'building': 'warehouse', 'product': 'vegetables'}, 'label': 'Vegetable Warehouse'},
            {'type': 'distribution', 'tags': {'shop': 'wholesale'}, 'label': 'Wholesale Market'},
            {'type': 'distribution', 'tags': {'amenity': 'marketplace'}, 'label': 'Traditional Market'},
            {'type': 'retail', 'tags': {'shop': 'greengrocer'}, 'label': 'Greengrocer'},
        ]
    },

    # ========================================================================
    # 5. DAGING AYAM / CHICKEN
    # ========================================================================
    'Daging Ayam': {
        'pihps_commodities': ['Daging Ayam Broiler'],
        'facilities': [
            {'type': 'production', 'tags': {'building': 'farm_auxiliary', 'livestock': 'poultry'}, 'label': 'Poultry Farm'},
            {'type': 'production', 'tags': {'landuse': 'farmyard', 'livestock': 'poultry'}, 'label': 'Poultry Farmyard'},
            {'type': 'processing', 'tags': {'amenity': 'slaughterhouse'}, 'label': 'Slaughterhouse'},
            {'type': 'processing', 'tags': {'industrial': 'slaughterhouse'}, 'label': 'Industrial Slaughterhouse'},
            {'type': 'storage', 'tags': {'building': 'cold_store'}, 'label': 'Cold Storage'},
            {'type': 'distribution', 'tags': {'shop': 'wholesale', 'product': 'meat'}, 'label': 'Meat Wholesale'},
            {'type': 'distribution', 'tags': {'amenity': 'marketplace'}, 'label': 'Traditional Market'},
            {'type': 'retail', 'tags': {'shop': 'butcher'}, 'label': 'Butcher Shop'},
        ]
    },

    # ========================================================================
    # 6. DAGING SAPI / BEEF
    # ========================================================================
    'Daging Sapi': {
        'pihps_commodities': ['Daging Sapi Kualitas 1', 'Daging Sapi Kualitas 2'],
        'facilities': [
            {'type': 'production', 'tags': {'building': 'farm_auxiliary', 'livestock': 'cattle'}, 'label': 'Cattle Farm'},
            {'type': 'production', 'tags': {'landuse': 'farmyard', 'livestock': 'cattle'}, 'label': 'Cattle Farmyard'},
            {'type': 'processing', 'tags': {'amenity': 'slaughterhouse'}, 'label': 'Slaughterhouse'},
            {'type': 'processing', 'tags': {'industrial': 'slaughterhouse'}, 'label': 'Industrial Slaughterhouse'},
            {'type': 'storage', 'tags': {'building': 'cold_store'}, 'label': 'Cold Storage'},
            {'type': 'distribution', 'tags': {'shop': 'wholesale', 'product': 'meat'}, 'label': 'Meat Wholesale'},
            {'type': 'distribution', 'tags': {'amenity': 'marketplace'}, 'label': 'Traditional Market'},
            {'type': 'retail', 'tags': {'shop': 'butcher'}, 'label': 'Butcher Shop'},
        ]
    },

    # ========================================================================
    # 7. TELUR AYAM / CHICKEN EGGS
    # ========================================================================
    'Telur Ayam': {
        'pihps_commodities': ['Telur Ayam Broiler'],
        'facilities': [
            {'type': 'production', 'tags': {'building': 'farm_auxiliary', 'livestock': 'poultry'}, 'label': 'Poultry Farm'},
            {'type': 'production', 'tags': {'landuse': 'farmyard', 'livestock': 'poultry'}, 'label': 'Poultry Farmyard'},
            {'type': 'distribution', 'tags': {'shop': 'wholesale'}, 'label': 'Wholesale Market'},
            {'type': 'distribution', 'tags': {'amenity': 'marketplace'}, 'label': 'Traditional Market'},
            {'type': 'retail', 'tags': {'shop': 'convenience'}, 'label': 'Convenience Store'},
            {'type': 'retail', 'tags': {'shop': 'supermarket'}, 'label': 'Supermarket'},
        ]
    },

    # ========================================================================
    # 8. MINYAK GORENG / COOKING OIL
    # ========================================================================
    'Minyak Goreng': {
        'pihps_commodities': [
            'Minyak Goreng Curah', 'Minyak Goreng Kemasan Bermerk 1',
            'Minyak Goreng Kemasan Bermerk 2'
        ],
        'facilities': [
            {'type': 'production', 'tags': {'industrial': 'oil_mill'}, 'label': 'Oil Mill'},
            {'type': 'production', 'tags': {'man_made': 'works', 'product': 'palm_oil'}, 'label': 'Palm Oil Factory'},
            {'type': 'storage', 'tags': {'building': 'warehouse', 'product': 'oil'}, 'label': 'Oil Warehouse'},
            {'type': 'distribution', 'tags': {'shop': 'wholesale'}, 'label': 'Wholesale Market'},
            {'type': 'distribution', 'tags': {'amenity': 'marketplace'}, 'label': 'Traditional Market'},
            {'type': 'retail', 'tags': {'shop': 'convenience'}, 'label': 'Convenience Store'},
            {'type': 'retail', 'tags': {'shop': 'supermarket'}, 'label': 'Supermarket'},
        ]
    },

    # ========================================================================
    # 9. GULA PASIR / SUGAR
    # ========================================================================
    'Gula Pasir': {
        'pihps_commodities': ['Gula Pasir Lokal', 'Gula Pasir Premium'],
        'facilities': [
            {'type': 'production', 'tags': {'industrial': 'sugar_mill'}, 'label': 'Sugar Mill'},
            {'type': 'production', 'tags': {'man_made': 'works', 'product': 'sugar'}, 'label': 'Sugar Factory'},
            {'type': 'production', 'tags': {'landuse': 'farmland', 'crop': 'sugarcane'}, 'label': 'Sugarcane Farm'},
            {'type': 'storage', 'tags': {'building': 'warehouse', 'product': 'sugar'}, 'label': 'Sugar Warehouse'},
            {'type': 'distribution', 'tags': {'shop': 'wholesale'}, 'label': 'Wholesale Market'},
            {'type': 'distribution', 'tags': {'amenity': 'marketplace'}, 'label': 'Traditional Market'},
            {'type': 'retail', 'tags': {'shop': 'convenience'}, 'label': 'Convenience Store'},
            {'type': 'retail', 'tags': {'shop': 'supermarket'}, 'label': 'Supermarket'},
        ]
    },
}


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """
    Calculate distance between two coordinates in kilometers using Haversine formula
    """
    R = 6371  # Earth radius in km

    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)

    a = (math.sin(dlat / 2) ** 2 +
         math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
         math.sin(dlon / 2) ** 2)
    c = 2 * math.asin(math.sqrt(a))

    return R * c


def build_optimized_batched_query(lat: float, lon: float, radius: int, commodity_dict: Dict) -> str:
    """
    Build SATU query besar yang mencakup SEMUA fasilitas untuk satu lokasi.
    Menggunakan 'union' untuk menggabungkan filter.
    Ini mengubah 45+ request per lokasi menjadi 1 request saja.
    """
    query_parts = []
    
    # Loop semua komoditas dan fasilitas
    for commodity, data in commodity_dict.items():
        for fac in data['facilities']:
            # Build tag string: ["key"="value"] atau ["key"~"value"]
            tag_filters = ""
            for k, v in fac['tags'].items():
                if '~' in k:
                    clean_k = k.replace('~', '')
                    tag_filters += f'["{clean_k}"~"{v}",i]'
                else:
                    tag_filters += f'["{k}"="{v}"]'
            
            # Tambahkan ke query parts: nwr[...](around:radius,lat,lon)
            query_parts.append(f'  nwr{tag_filters}(around:{radius},{lat},{lon});')
    
    # Gabungkan semua sub-query
    union_query = "\n".join(query_parts)
    
    full_query = f"""
[out:json][timeout:180];
(
{union_query}
);
out center;
    """
    return full_query


def match_tags_to_config(element_tags: Dict, commodity_dict: Dict) -> List[Dict]:
    """
    Karena kita mengambil 'bulk', kita harus mencocokkan kembali 
    hasil OSM ke kategori komoditas kita secara manual di Python (ini sangat cepat di CPU).
    """
    matches = []
    for commodity, data in commodity_dict.items():
        for fac in data['facilities']:
            is_match = True
            for k, v in fac['tags'].items():
                # Logic matching
                if '~' in k:  # Regex logic (simplified)
                    clean_k = k.replace('~', '')
                    if clean_k not in element_tags:
                        is_match = False
                        break
                    # Simple case-insensitive substring match
                    if v.lower() not in element_tags[clean_k].lower():
                        is_match = False
                        break
                else:  # Exact match
                    if k not in element_tags or element_tags[k] != v:
                        is_match = False
                        break
            
            if is_match:
                matches.append({
                    'commodity': commodity,
                    'facility_type': fac['type'],
                    'facility_label': fac['label']
                })
    return matches


def fetch_location_data_batched(args: tuple) -> Optional[Dict]:
    """
    Fetch SEMUA data untuk satu lokasi dalam SATU request.
    Ini mengurangi jumlah request dari 450+ menjadi hanya 10 (satu per lokasi).
    """
    location_name, lat, lon, commodity_dict = args
    
    # Pilih server secara acak untuk load balancing
    server = random.choice(OVERPASS_SERVERS)
    
    query = build_optimized_batched_query(lat, lon, SEARCH_RADIUS_METERS, commodity_dict)
    
    max_retries = 5
    for attempt in range(max_retries):
        try:
            logger.info(f"Fetching {location_name} from {server} (Attempt {attempt+1})")
            
            response = requests.post(server, data=query, timeout=200)
            
            if response.status_code == 200:
                data = response.json()
                return {
                    'location': location_name,
                    'lat': lat,
                    'lon': lon,
                    'elements': data.get('elements', [])
                }
            elif response.status_code == 429:
                # Kena rate limit, tunggu random time dan ganti server
                sleep_time = (attempt + 1) * 5 + random.uniform(1, 5)
                logger.warning(f"Rate limit 429 at {location_name}. Sleeping {sleep_time:.1f}s")
                time.sleep(sleep_time)
                server = random.choice(OVERPASS_SERVERS)  # Switch server
            else:
                logger.error(f"Error {response.status_code} for {location_name}")
                time.sleep(5)
                
        except Exception as e:
            logger.error(f"Exception fetching {location_name}: {e}")
            time.sleep(5)
            server = random.choice(OVERPASS_SERVERS)
            
    return None


# ============================================================================
# MAIN FUNCTION
# ============================================================================

def main():
    """
    Main orchestration function
    """
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

    logger.info("="*80)
    logger.info("SUPPLY CHAIN SPATIAL ANALYSIS")
    logger.info("="*80)
    logger.info(f"Research Goal: Map ALL facilities in ALL locations")
    logger.info(f"              to analyze spatial influence on prices")
    logger.info("")
    logger.info(f"Locations: {len(LOCATION_COORDS)}")
    logger.info(f"Commodities: {len(SUPPLY_CHAIN_TAGS)}")

    # ========================================================================
    # STEP 1: Build BATCHED search tasks (1 task per lokasi)
    # ========================================================================
    logger.info("\nBuilding BATCHED search tasks (1 query per location)...")

    tasks = []
    for loc, coords in LOCATION_COORDS.items():
        tasks.append((loc, coords[0], coords[1], SUPPLY_CHAIN_TAGS))

    total_tasks = len(tasks)
    logger.info(f"Total search tasks: {total_tasks} (OPTIMIZED from {len(LOCATION_COORDS) * sum(len(v['facilities']) for v in SUPPLY_CHAIN_TAGS.values())} individual queries!)")
    logger.info(f"Each task fetches ALL facilities for one location in a SINGLE request")

    # ========================================================================
    # STEP 2: Execute searches with multiprocessing
    # ========================================================================
    # Bisa pakai worker lebih banyak karena kita rotasi server
    # Tapi karena task cuma 10 (jumlah kota), 4-5 worker sudah cukup
    n_workers = min(5, cpu_count())
    logger.info(f"\nUsing {n_workers} worker processes (with server rotation)")
    logger.info("Starting parallel search...\n")

    raw_results = []
    with Pool(processes=n_workers) as pool:
        with tqdm(total=total_tasks, desc="Searching OSM", unit="location") as pbar:
            for result in pool.imap_unordered(fetch_location_data_batched, tasks):
                if result is not None:
                    raw_results.append(result)
                pbar.update(1)

    logger.info(f"\nCompleted {len(raw_results)} successful searches (out of {total_tasks} locations)")

    # ========================================================================
    # STEP 3: Process and structure results (LOCAL POST-PROCESSING)
    # ========================================================================
    logger.info("\nProcessing raw data locally (CPU-bound, very fast)...")

    all_facilities = []

    for res in raw_results:
        loc_name = res['location']
        loc_lat = res['lat']
        loc_lon = res['lon']
        
        for element in res['elements']:
            # Extract coordinates
            if 'lat' in element:
                el_lat, el_lon = element['lat'], element['lon']
            elif 'center' in element:
                el_lat, el_lon = element['center']['lat'], element['center']['lon']
            else:
                continue
            
            tags = element.get('tags', {})
            
            # Cek elemen ini masuk kategori mana saja
            # (Satu Rice Mill bisa masuk ke kategori Beras, dll)
            matched_categories = match_tags_to_config(tags, SUPPLY_CHAIN_TAGS)
            
            if not matched_categories:
                continue
            
            # Extract name
            name = tags.get('name', 'Unnamed')
            
            # Calculate distance to search location
            distance_km = haversine_distance(loc_lat, loc_lon, el_lat, el_lon)
            
            # Satu facility bisa match ke multiple commodities
            for match in matched_categories:
                facility_record = {
                    'osm_id': element['id'],
                    'osm_type': element['type'],
                    'commodity': match['commodity'],
                    'facility_type': match['facility_type'],
                    'facility_label': match['facility_label'],
                    'name': name,
                    'latitude': el_lat,
                    'longitude': el_lon,
                    'search_location': loc_name,
                    'search_location_lat': loc_lat,
                    'search_location_lon': loc_lon,
                    'distance_to_location_km': round(distance_km, 2),
                    'tags': json.dumps(tags, ensure_ascii=False),
                    'retrieved_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                }
                all_facilities.append(facility_record)

    # ========================================================================
    # STEP 4: Save results
    # ========================================================================

    # Save all facilities
    if all_facilities:
        df_facilities = pd.DataFrame(all_facilities)

        # Remove duplicates (same facility found from multiple searches)
        df_facilities = df_facilities.drop_duplicates(
            subset=['osm_id', 'commodity', 'facility_type']
        )

        facilities_file = f"{OUTPUT_DIR}/supply_chain_facilities_{timestamp}.csv"
        df_facilities.to_csv(facilities_file, index=False, encoding='utf-8-sig')

        logger.info(f"\nTotal unique facilities found: {len(df_facilities):,}")
        logger.info(f"Saved to: {facilities_file}")

        # ====================================================================
        # STEP 5: Generate Summary Statistics
        # ====================================================================
        logger.info("\n" + "="*80)
        logger.info("SUMMARY STATISTICS")
        logger.info("="*80)

        # By commodity
        logger.info("\nFacilities by Commodity:")
        commodity_counts = df_facilities.groupby('commodity').size().sort_values(ascending=False)
        for commodity, count in commodity_counts.items():
            logger.info(f"  {commodity:20s}: {count:5d} facilities")

        # By facility type
        logger.info("\nFacilities by Type:")
        type_counts = df_facilities.groupby('facility_type').size().sort_values(ascending=False)
        for ftype, count in type_counts.items():
            logger.info(f"  {ftype:20s}: {count:5d} facilities")

        # By location
        logger.info("\nFacilities by Location:")
        location_counts = df_facilities.groupby('search_location').size().sort_values(ascending=False)
        for location, count in location_counts.items():
            logger.info(f"  {location:20s}: {count:5d} facilities")

        # ====================================================================
        # STEP 6: Generate Location-Facility Summary Matrix
        # ====================================================================
        logger.info("\nGenerating location-facility summary matrix...")

        summary_data = []
        for location in LOCATION_COORDS.keys():
            location_facilities = df_facilities[df_facilities['search_location'] == location]

            for commodity in SUPPLY_CHAIN_TAGS.keys():
                commodity_facilities = location_facilities[location_facilities['commodity'] == commodity]

                # Count by type
                production_count = len(commodity_facilities[commodity_facilities['facility_type'] == 'production'])
                processing_count = len(commodity_facilities[commodity_facilities['facility_type'] == 'processing'])
                storage_count = len(commodity_facilities[commodity_facilities['facility_type'] == 'storage'])
                distribution_count = len(commodity_facilities[commodity_facilities['facility_type'] == 'distribution'])
                retail_count = len(commodity_facilities[commodity_facilities['facility_type'] == 'retail'])

                # Distance to nearest facilities
                if len(commodity_facilities) > 0:
                    nearest_distance = commodity_facilities['distance_to_location_km'].min()
                else:
                    nearest_distance = None

                summary_data.append({
                    'location': location,
                    'commodity': commodity,
                    'total_facilities': len(commodity_facilities),
                    'production_count': production_count,
                    'processing_count': processing_count,
                    'storage_count': storage_count,
                    'distribution_count': distribution_count,
                    'retail_count': retail_count,
                    'nearest_facility_km': nearest_distance
                })

        df_summary = pd.DataFrame(summary_data)
        summary_file = f"{OUTPUT_DIR}/location_facility_summary_{timestamp}.csv"
        df_summary.to_csv(summary_file, index=False, encoding='utf-8-sig')
        logger.info(f"Saved location-facility summary: {summary_file}")

        # ====================================================================
        # STEP 7: Generate Spatial Features for Analysis
        # ====================================================================
        logger.info("\nGenerating spatial features for price analysis...")

        spatial_features = []
        for location in LOCATION_COORDS.keys():
            location_lat, location_lon = LOCATION_COORDS[location]

            for commodity in SUPPLY_CHAIN_TAGS.keys():
                # Get all facilities for this commodity
                commodity_facilities = df_facilities[df_facilities['commodity'] == commodity]

                # Distance to nearest production facility
                production_facilities = commodity_facilities[commodity_facilities['facility_type'] == 'production']
                if len(production_facilities) > 0:
                    distances = production_facilities.apply(
                        lambda row: haversine_distance(location_lat, location_lon, row['latitude'], row['longitude']),
                        axis=1
                    )
                    nearest_production_km = distances.min()
                    avg_production_distance_km = distances.mean()
                else:
                    nearest_production_km = None
                    avg_production_distance_km = None

                # Distance to nearest distribution
                distribution_facilities = commodity_facilities[commodity_facilities['facility_type'] == 'distribution']
                if len(distribution_facilities) > 0:
                    distances = distribution_facilities.apply(
                        lambda row: haversine_distance(location_lat, location_lon, row['latitude'], row['longitude']),
                        axis=1
                    )
                    nearest_distribution_km = distances.min()
                    avg_distribution_distance_km = distances.mean()
                else:
                    nearest_distribution_km = None
                    avg_distribution_distance_km = None

                # Distance to nearest retail
                retail_facilities = commodity_facilities[commodity_facilities['facility_type'] == 'retail']
                if len(retail_facilities) > 0:
                    distances = retail_facilities.apply(
                        lambda row: haversine_distance(location_lat, location_lon, row['latitude'], row['longitude']),
                        axis=1
                    )
                    nearest_retail_km = distances.min()
                else:
                    nearest_retail_km = None

                spatial_features.append({
                    'location': location,
                    'commodity': commodity,
                    'nearest_production_km': nearest_production_km,
                    'avg_production_distance_km': avg_production_distance_km,
                    'nearest_distribution_km': nearest_distribution_km,
                    'avg_distribution_distance_km': avg_distribution_distance_km,
                    'nearest_retail_km': nearest_retail_km,
                })

        df_spatial = pd.DataFrame(spatial_features)
        spatial_file = f"{OUTPUT_DIR}/spatial_features_{timestamp}.csv"
        df_spatial.to_csv(spatial_file, index=False, encoding='utf-8-sig')
        logger.info(f"Saved spatial features: {spatial_file}")

        # ====================================================================
        # STEP 8: Analysis Insights
        # ====================================================================
        logger.info("\n" + "="*80)
        logger.info("ANALYSIS INSIGHTS")
        logger.info("="*80)

        logger.info("\nNext Steps for Spatial Price Analysis:")
        logger.info("1. Merge spatial_features.csv dengan data harga PIHPS")
        logger.info("2. Analisis korelasi: jarak ke production vs harga")
        logger.info("3. Identifikasi lokasi dengan gap infrastruktur:")
        logger.info("   - Harga tinggi tapi tidak ada production facility nearby")
        logger.info("   - Potensi optimalisasi: bangun distributor/storage di lokasi tsb")
        logger.info("4. Regresi model: price ~ distance_to_production + distance_to_distribution")
        logger.info("5. Spatial clustering: group lokasi dengan pola supply chain serupa")

        logger.info("\n" + "="*80)
        logger.info("COMPLETED!")
        logger.info("="*80)

    else:
        logger.warning("\nNo facilities found!")
        logger.warning("Possible reasons:")
        logger.warning("- Rate limiting dari OSM Overpass API")
        logger.warning("- Area names tidak cocok dengan OSM")
        logger.warning("- Tags terlalu spesifik")


if __name__ == "__main__":
    main()
